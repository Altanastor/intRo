
# This is the server logic for a Shiny web application.
# You can find out more about building applications with Shiny here:
# 
# http://www.rstudio.com/shiny/
#

library(shiny)
library(ggplot2)
library(ggvis)
library(shinyAce)
library(YaleToolkit)
library(lubridate)
library(gridExtra)

numericNames <- function(data) {
    return(as.character(subset(whatis(data), type == "numeric" & !(variable.name %in% c("year", "month", "day", "Year", "Month", "Day")))$variable.name))
}

shinyServer(function(input, output, session) {
    
    textStorage <- paste("### Code generated by intRo on", today(), "\n\n")
    values <- reactiveValues(firstrun = TRUE)
    
    sourceDir <- function(path, ...) { for (nm in list.files(path, pattern = "\\.[Rr]$")) { source(file.path(path, nm), ...) } }
    sourceDir("modules")
    valid.datasets <- list(mpg = mpg, airquality = airquality, diamonds = diamonds)
    valid.plottypes <- list(scatterplot = scatterplot, linechart = linechart,
                            histogram = histogram, boxplot1 = boxplot1,
                            boxplot2 = boxplot2, barchart = barchart,
                            paretochart = paretochart,
                            quantileplot = quantileplot)
    valid.bartypes <- list(length = length, sum = sum, mean = mean, median = median)
    
    observe({
        if (input$vars == "onevar") updateSelectInput(session, "plottype", choices = c("Histogram" = "histogram", "Boxplot" = "boxplot1", "Normal Quantile Plot" = "quantileplot"), selected = "histogram")
    })
    
    observe({
        if (input$vars == "onevar") {
            updateSelectInput(session, "x", choices = numericNames(intro.data()), selected = NA)
            updateSelectInput(session, "y", choices = numericNames(intro.data()), selected = NA)
        }

        if (input$varts == "twovart") {
            updateSelectInput(session, "group2", choices = numericNames(intro.data()))
        }
    })
    
    observe({
        updateSelectInput(session, "group1", choices = numericNames(intro.data()), selected = NA)
        updateSelectInput(session, "xreg", choices = numericNames(intro.data()), selected = NA)
        updateSelectInput(session, "yreg", choices = numericNames(intro.data()), selected = NA)
    })
    
    observe({
        if (input$vars == "twovar") updateSelectInput(session, "plottype", choices = c("Scatterplot" = "scatterplot", "Line Chart" = "linechart", "Boxplot" = "boxplot2", "Bar Chart" = "barchart", "Pareto Chart" = "paretochart"), selected = "scatterplot")
    })
    
    observe({
        nms <- numericNames(intro.data())
        all.nms <- names(intro.data())
        new.x <- if (input$x %in% nms) input$x else nms[1]
        new.y <- if (input$y %in% nms) input$y else nms[2]
        
        updateCheckboxGroupInput(session, "tblvars", choices=all.nms, selected = NA)
        
        if (input$vars == "twovar") {
            updateSelectInput(session, "y", choices = nms, selected = new.y)
            if (input$plottype %in% c("scatterplot", "linechart")) {
                updateSelectInput(session, "x", choices = nms, selected = new.x)
            } else if (input$plottype %in% c("boxplot2", "barchart", "paretochart")) {
                updateSelectInput(session, "x", choices = all.nms, selected = input$x)
            }
        }
    })
    
    observe({
        curdata <- intro.data()
        curx <- input$x
        cury <- input$y
        if (!is.null(curx) & curx %in% names(curdata)) {
            if (is.numeric(curdata[,curx])) {
                rng <- range(curdata[,curx], na.rm = TRUE)
                updateNumericInput(session, "binwidth", value=round((rng[2] - rng[1])/30, digits = 2))
            }
            
            if (input$vars == "onevar" | (!is.null(cury) & cury %in% names(curdata))) chosen.plot()(curdata, input$x, input$y, chosen.bartype(), input$binwidth) %>% bind_shiny("plot")
        }
    })

    observe({
        curdata <- intro.data()
        curxreg <- input$xreg
        curyreg <- input$yreg
                        
        if (!is.null(curxreg) & !is.null(curyreg) & curxreg %in% names(curdata) & curyreg %in% names(curdata)) {
            scatterplotreg(curdata, input$xreg, input$yreg) %>% bind_shiny("regplot")
            residualreg1(intro.data(), curxreg, curyreg) %>% bind_shiny("resplot1")
            residualreg2(intro.data(), curxreg, curyreg) %>% bind_shiny("resplot2")
            residualreg3(intro.data(), curxreg, curyreg) %>% bind_shiny("resplot3")
        }
    })
    
    process_logical <- function(data, x) {
        if (is.null(x)) {
            return(data)
        }

        relevant_cols <- names(data)[nchar(x) > 0]
        my_strs <- strsplit(gsub(",", " , ", x), split = ",")
        new_strs <- my_strs[unlist(lapply(my_strs, length)) > 0]

        new_data <- data
        if (length(new_strs) > 0) {
            for (i in 1:length(new_strs)) {
                test <- new_strs[[i]]
                col <- relevant_cols[i]
                
                subset_str <- ""
                if (length(test) == 1) {
                    if (is.na(as.numeric(test[1]))) {
                        subset_str <- paste0("'", test[1], "' == ", col)
                    } else {
                        subset_str <- paste(test[1], "==", col)
                    }
                } else {
                    test[1] <- ifelse(test[1] == " ", -Inf, test[1])
                    test[2] <- ifelse(test[2] == " ", Inf, test[2])
                    if (is.na(test[2])) test[2] <- Inf
                    
                    subset_str <- paste(test[1], "<=", col, "&", col, "<=", test[2])
                }          
                new_data <- eval(parse(text = paste0("subset(new_data, ", subset_str, ")")))
            }
        }
                
        return(new_data)
    }
    
    mydat <- NULL
    oldval <- 0
    intro.start <- reactive({
        
        #dependency on input$clearssubset
        if (input$clearsubset > oldval) {
            updateCheckboxInput(session, "randomsub", value = FALSE)
            oldval <<- input$clearsubset
        }
      
        data.initial <- data.module(input$data_own, chosen.data(), input$own)
        
        if (values$firstrun) textStorage <<- paste(textStorage, "### ", input$`side-nav`,"\n", paste(c(readLines(paste("modules/", input$`side-nav`, ".R", sep = ""))), collapse = "\n"), "\n\n", sep = "")
        
        if (values$firstrun) {
            updateAceEditor(session, "myEditor", value=textStorage)
            values$firstrun <- FALSE
        }
                
        if (input$randomsub & all(input$subs == "")) {
            data.initial <- dplyr::sample_n(data.initial, input$randomsubrows)
        } else if (input$randomsub) {
            data.initial <- dplyr::sample_n(mydat, input$randomsubrows)
        }
        mydat <<- data.initial
                
        return(data.initial)
    })
    
    oldsaveresid <- 0
    
    intro.data <- reactive({
        if (is.null(intro.start())) return(NULL)

        data.subset <- process_logical(mydat, input$subs)
        mydat <<- data.subset
        
        if (input$saveresid > oldsaveresid) {
            curxreg <- input$xreg
            curyreg <- input$yreg
            
            if (!is.null(curxreg) & !is.null(curyreg) & curxreg %in% names(mydat) & curyreg %in% names(mydat)) {
                mydat <<- savefit(mydat, input$xreg, input$yreg)
            }
            
            oldsaveresid <<- input$saveresid
        }
        
        return(mydat)
    })

    observe({
        if (!values$firstrun) {
            new.tab <- input$`side-nav`
            new.str <-  paste("### ", paste(input$`side-nav`, "\n", paste(readLines(paste("modules/", new.tab, ".R", sep = "")), collapse = "\n"), sep = ""), "\n\n", sep = "")
            
            ### Special case for plots
            if (input$`side-nav` == "Graphical") {
                new.str <- paste("### ", paste(new.tab, "\n", input$plottype, " <- ", paste(deparse(get(input$plottype)), collapse = "\n"), sep = ""), "\n\n", sep = "")
            }
            
            text.split <- strsplit(textStorage, "### ")[[1]]
            text.split <- text.split[-(text.split == "")]
            text.ind <- grep(input$`side-nav`, text.split)
            if (length(text.ind) == 0) text.ind <- length(text.split) + 1
            text.split[-text.ind] <- paste("###", text.split[-text.ind])
            text.split[text.ind] <- new.str
            
            textStorage <<- paste(text.split, collapse = "")
            
            updateAceEditor(session, "myEditor", value=textStorage)
        }
    })
    
    output$downloaddata <- downloadHandler(
        filename = function() { paste0("intro_data_", today(), ".csv") },
        content = function(file) {
            write.csv(intro.data(), file)
        }
    )
    
    chosen.data <- reactive({
        return(valid.datasets[[input$data]])
    })
    
    chosen.plot <- reactive({
        return(valid.plottypes[[input$plottype]])
    })
    
    chosen.bartype <- reactive({
        return(valid.bartypes[[input$bartype]])
    })

    output$data <- renderDataTable({
        return(intro.data())
    }, options = list(iDisplayLength = 10))
    
    output$summary <- renderTable({
        return(summarytable(intro.data(), input$tblvars))
    }, include.rownames = FALSE)
    
    output$regtable <- renderTable({
        if (is.null(input$xreg) | !(input$xreg %in% numericNames(intro.data())) | is.null(input$yreg) | !(input$yreg %in% numericNames(intro.data()))) return(NULL)
        else return(tablereg(intro.data(), input$xreg, input$yreg))
    }, digits = 4)
    
    output$r <- renderText({
        if (is.null(input$xreg) | !(input$xreg %in% numericNames(intro.data())) | is.null(input$yreg) | !(input$yreg %in% numericNames(intro.data()))) return(NULL)
        else return(r(intro.data(), input$xreg, input$yreg))
    })
    
    output$r2 <- renderText({
        if (is.null(input$xreg) | !(input$xreg %in% numericNames(intro.data())) | is.null(input$yreg) | !(input$yreg %in% numericNames(intro.data()))) return(NULL)
        return(r2(intro.data(), input$xreg, input$yreg))
    })
    
    output$ttesttable <- renderText({
        if (is.null(input$group1) | !(input$group1 %in% numericNames(intro.data()))) return(NULL)
        return(ttesttable(intro.data(), input$group1, input$group2, input$varts == "twovart", input$conflevel, input$althyp, input$hypval))
    })
})
