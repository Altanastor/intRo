library(shiny)
library(ggplot2)
library(dplyr)
library(ggvis)
library(shinyAce)
library(YaleToolkit)
library(lubridate)
library(gridExtra)

###
### Helper Functions
###
numericNames <- function(data) {
    vec <- as.character(subset(whatis(data), type == "numeric")$variable.name)
    if (length(vec) == 0) vec <- ""
    
    return(vec)
}

categoricNames <- function(data) {
    vec <- as.character(subset(whatis(data), type != "numeric")$variable.name)
    if (length(vec) == 0) vec <- ""
    
    return(vec)
}

checkVariable <- function(data, var) {
    return(nchar(var) > 0 & var %in% names(data))
}

my.summary <- function(x) {
    return(c(summary(x), "SD" = sd(x, na.rm = TRUE)))
}

process_logical <- function(data, x) {
    if (is.null(x)) {
        return(data)
    }
    
    relevant_cols <- names(data)[nchar(x) > 0]
    if (length(relevant_cols) == 0) return(data)
    
    my_strs <- strsplit(gsub(",", " , ", x), split = ",")
    new_strs <- my_strs[unlist(lapply(my_strs, length)) > 0]
    
    new_data <- data
    if (length(new_strs) > 0) {
        for (i in 1:length(new_strs)) {
            test <- new_strs[[i]]
            col <- relevant_cols[i]
            
            subset_str <- ""
            if (length(test) == 1) {
                if (is.na(as.numeric(test[1]))) {
                    subset_str <- paste0("'", test[1], "' == ", col)
                } else {
                    subset_str <- paste(test[1], "==", col)
                }
            } else {
                test[1] <- ifelse(test[1] == " ", -Inf, test[1])
                test[2] <- ifelse(test[2] == " ", Inf, test[2])
                if (is.na(test[2])) test[2] <- Inf
                
                subset_str <- paste(test[1], "<=", col, "&", col, "<=", test[2])
            }          
            
            new_data <- eval(parse(text = paste0("subset(new_data, ", subset_str, ")")))
        }
    }
    
    return(new_data)
}

###
### Shiny Server definition
###
shinyServer(function(input, output, session) {
    
    textStorage <- paste("### Code generated by intRo on", today(), "\n\n")
    values <- reactiveValues(firstrun = TRUE, mydat = NULL, mydat_rand = NULL)
    
    sourceDir <- function(path, ...) { for (nm in list.files(path, pattern = "\\.[Rr]$")) { source(file.path(path, nm), ...) } }
    sourceDir("modules")
    
    valid.datasets <- list(mpg = mpg, airquality = airquality, diamonds = read.csv("data/diamonds_sub.csv"))
    valid.plottypes <- list(scatterplot = scatterplot, linechart = linechart,
                            histogram = histogram,
                            boxplot = boxplot, barchart = barchart,
                            paretochart = paretochart,
                            quantileplot = quantileplot,
                            mosaicplot = mosaicplot)
    valid.bartypes <- list(length = length, sum = sum, mean = mean, median = median)
    
    ###
    ### Reactive Observers
    ###
    
    x_choices <- reactive({
        if (input$plottype %in% c("boxplot", "barchart", "paretochart", "mosaicplot")) intro.categoricnames()
        else intro.numericnames()
    })
    
    y_choices <- reactive({
        if (input$plottype %in% c("mosaicplot")) intro.categoricnames()
        else intro.numericnames()
    })
    
    x_selected <- reactive({
        x_choices()[1]
    })
    
    y_selected <- reactive({
        y_choices()[1]
    })
    
    ## Graphical Observers
    observe({
        input$plottype
        updateSelectInput(session, "x", choices = x_choices(), selected = x_selected())
    })
    observe({
        input$plottype
        updateSelectInput(session, "y", choices = y_choices(), selected = y_selected())
    })
    
    ## Transform Observers
    observe({
        updateSelectInput(session, "var_trans", choices = (if (input$trans %in% c("power", "categorical")) intro.numericnames() else intro.categoricnames()))
    })
    
    ## Regression Observers
    observe({
        updateSelectInput(session, "xreg", choices = intro.numericnames())
        updateSelectInput(session, "yreg", choices = intro.numericnames())
    })
    
    ## Other Input Observers
    observe({
        updateSelectInput(session, "xcont", choices = intro.categoricnames(), selected = ifelse(checkVariable(intro.data(), input$xcont), input$xcont, intro.categoricnames()[1]))
        updateSelectInput(session, "ycont", choices = intro.categoricnames(), selected = ifelse(checkVariable(intro.data(), input$ycont), input$ycont, intro.categoricnames()[2]))
        updateSelectInput(session, "group1", choices = intro.numericnames(), selected = ifelse(checkVariable(intro.data(), input$group1), input$group1, intro.numericnames()[1]))
        updateSelectInput(session, "group2", choices = intro.numericnames(), selected = ifelse(checkVariable(intro.data(), input$group2), input$group2, intro.numericnames()[2]))
        updateSelectInput(session, "grouping", choices = c("None" = "none", names(intro.data())))
        updateNumericInput(session, "randomsubrows", max = nrow(intro.data()))
        updateCheckboxGroupInput(session, "tblvars", choices = names(intro.data()))
    })
    
    ## Text Processing
    observe({
        if (!values$firstrun) {
            new.tab <- input$`side-nav`
            new.str <-  paste("### ", paste(input$`side-nav`, "\n", paste(readLines(paste("modules/", new.tab, ".R", sep = "")), collapse = "\n"), sep = ""), "\n\n", sep = "")
            
            ### Special case for plots
            if (input$`side-nav` == "Graphical") {
                new.str <- paste("### ", paste(new.tab, "\n", input$plottype, " <- ", paste(deparse(get(input$plottype)), collapse = "\n"), sep = ""), "\n\n", sep = "")
            }
            
            text.split <- strsplit(textStorage, "### ")[[1]]
            text.split <- text.split[-(text.split == "")]
            text.ind <- grep(input$`side-nav`, text.split)
            if (length(text.ind) == 0) text.ind <- length(text.split) + 1
            text.split[-text.ind] <- paste("###", text.split[-text.ind])
            text.split[text.ind] <- new.str
            
            textStorage <<- paste(text.split, collapse = "")
            
            updateAceEditor(session, "myEditor", value=textStorage)
        }
    })
    
    ## Static vars for buttons
    oldval <- 0
    oldsaveresid <- 0
    oldsavetrans <- 0
    oldsavesub <- 0
    
    ###
    ### Reactive data
    ###
    intro.start <- reactive({
        input$clearsubset

        data.initial <- data.module(input$data_own, valid.datasets[[input$data]], input$own)
        
        if (values$firstrun) textStorage <<- paste(textStorage, "### ", input$`side-nav`,"\n", paste(c(readLines(paste("modules/", input$`side-nav`, ".R", sep = ""))), collapse = "\n"), "\n\n", sep = "")
        
        if (values$firstrun) {
            updateAceEditor(session, "myEditor", value=textStorage)
            values$firstrun <- FALSE
        }
                
        values$mydat <<- data.initial
                
        return(data.initial)
    })
    
    intro.data <- reactive({
        if (is.null(intro.start())) return(NULL)
        
        data.subset <- process_logical(values$mydat, input$subs)
        values$mydat <<- data.subset
        values$mydat_rand <<- values$mydat
        
        if (input$randomsub & is.numeric(input$randomsubrows) & input$randomsubrows >= 1 & input$randomsubrows <= nrow(values$mydat)) {
            values$mydat_rand <<- dplyr::sample_n(values$mydat, input$randomsubrows)
        }
        
        if (input$savesubset > oldsavesub) {
            values$mydat <<- values$mydat_rand
            oldsavesub <<- input$savesubset
        }
        
        return(values$mydat)
    })
    
    intro.numericnames <- reactive({
        if (is.null(intro.data())) return(NULL)
        
        return(numericNames(intro.data()))
    })
    
    intro.categoricnames <- reactive({
        if (is.null(intro.data())) return(NULL)
        
        return(categoricNames(intro.data()))
    })
    
    intro.transform.colname <- reactive({
        if (is.null(intro.data())) return(NULL)
        
        curdata <- intro.data()
        curtrans <- input$var_trans
        colname <- ""
        
        if (input$trans == "power") {
            colname <- paste(curtrans, sub("\\.", "", input$power), sep = "_")
        } else if (input$trans %in% c("categorical", "numeric")) {
            colname <- paste(curtrans, "trans", sep = "_")
        }
        
        return(colname)
    })
    
    output$var_trans_text <- renderText({
        if (is.null(intro.transform())) return(NULL)
        
        return(paste("Selected Variable:", input$var_trans))
    })
    
    intro.transform <- reactive({
        if (is.null(intro.data())) return(NULL)
                        
        curdata <- intro.data()
        curtrans <- input$var_trans
                
        if (input$trans == "power") {
            trans_x <- if (input$power == 0) log(curdata[,curtrans]) else (curdata[,curtrans])^(input$power)
            if (all(!is.infinite(trans_x))) {
                curdata[, intro.transform.colname()] <- as.numeric(trans_x)
            }
        } else if (input$trans %in% c("categorical", "numeric")) {
            trans_x <- if (input$trans == "numeric") as.numeric(curdata[,curtrans]) else factor(curdata[,curtrans])
            curdata[, intro.transform.colname()] <- trans_x
        }
                
        if (input$savetrans > oldsavetrans) {
            values$mydat <<- curdata
            oldsavetrans <<- input$savetrans
        }
        
        if (is.numeric(curdata[,curtrans])) curdata$var <- curdata[,curtrans] else curdata$var <- 0
        if (is.numeric(curdata[,intro.transform.colname()])) curdata$trans_var <- curdata[,intro.transform.colname()] else curdata$trans_var <- 0
        
        return(curdata)
    })
    
    intro.regression <- reactive({
        if (is.null(intro.data())) return(NULL)
        
        lm.fit <- lm(intro.data()[,input$yreg] ~ intro.data()[,input$xreg])
        
        if (input$saveresid > oldsaveresid) {
            curxreg <- input$xreg
            curyreg <- input$yreg
            
            values$mydat <<- savefit(intro.data(), input$xreg, input$yreg, lm.fit)
            
            oldsaveresid <<- input$saveresid
        }
        
        return(lm.fit)
    })
    
    intro.transform %>%
        ggvis(x = ~var) %>%
        layer_histograms() %>%
        bind_shiny("var_plot")

    intro.transform %>%
        ggvis(x = ~trans_var) %>%
        layer_histograms() %>%
        bind_shiny("trans_plot")
    
    intro.plot <- reactive({
        if (is.null(intro.data())) return(NULL)
        
        mydat <- intro.data()

        mydat$intro_x_cat <- factor(mydat[,input$x]) 
        mydat$intro_x_num <- as.numeric(mydat[,input$x])
        mydat$intro_y_cat <- factor(mydat[,input$y])
        mydat$intro_y_num <- as.numeric(mydat[,input$y])
        
        if (input$plottype == "paretochart") mydat$intro_x_cat <- factor(mydat$intro_x_cat, levels = names(sort(table(mydat$intro_x_cat), decreasing = TRUE)))
        
        return(mydat)
    })
    
    intro.quant <- reactive({
        if (is.null(intro.plot())) return(NULL)
        
        mydat <- intro.plot()
        
        yy <- quantile(mydat$intro_x_num, na.rm = TRUE, c(0.25, 0.75))
        xx <- qnorm(c(0.25, 0.75))
        slope <- diff(yy) / diff(xx)
        int <- yy[1] - slope * xx[1]
        
        mydat$intro_quant <- qnorm(seq(0, 1, by = (1/(length(mydat$intro_x_num) + 1)))[-c(1, (length(mydat$intro_x_num) + 2))])
        mydat$intro_x_num <- sort(mydat$intro_x_num)
        
        return(mydat)
    })
    
   intro.plot %>%
        ggvis(x = ~intro_x_num, y = ~intro_y_num) %>%
        layer_histograms(width = input_slider(1, 20, 1, label = "Bin Width")) %>% 
        bind_shiny("histogram", "histogram_ui")  

    intro.quant %>%
        ggvis(x = ~intro_quant, y = ~intro_x_num) %>%
        layer_points() %>%
        bind_shiny("quantileplot")
    
    intro.plot %>%
        ggvis(x = ~intro_x_num, y = ~intro_y_num) %>%
        layer_points() %>%
        bind_shiny("scatterplot")
    
    intro.plot %>%
        ggvis(x = ~intro_x_num, y = ~intro_y_num) %>%
        layer_lines() %>%
        bind_shiny("linechart")
    
    intro.plot %>%
        ggvis(x = ~intro_x_cat, y = ~intro_y_num) %>%
        layer_boxplots() %>%
        bind_shiny("boxplot")
    
    intro.plot %>%
        ggvis(x = ~intro_x_cat, y = ~intro_y_num) %>%
        layer_bars() %>%
        bind_shiny("barchart")
    
    intro.plot %>%
        ggvis(x = ~intro_x_cat, y = ~intro_y_num) %>%
        layer_bars() %>%
        bind_shiny("paretochart")
    
    reg.data <- reactive({
        if (is.null(intro.regression())) return(NULL)
        
        reg.data <- intro.data()
        reg.data$xreg <- reg.data[,input$xreg]
        reg.data$yreg <- reg.data[,input$yreg]
        
        return(reg.data)
    })
    
    reg.data %>%
        ggvis(x = ~xreg, y = ~yreg) %>%
        layer_points() %>%
        layer_model_predictions(model = "lm") %>% 
        bind_shiny("regplot")
    
    reg.resid1 <- reactive({
        if (is.null(intro.regression())) return(NULL)
        
        mydat <- data.frame(residuals = resid(intro.regression()), x = intro.data()[as.numeric(names(resid(intro.regression()))),input$xreg])
        
        return(mydat)
    })
    
    reg.resid1 %>%
        ggvis(x = ~x, y = ~residuals) %>%
        layer_points() %>%
        set_options(width = 200, height = 200) %>% 
        bind_shiny("resplot1")
    
    reg.resid2 <- reactive({
        if (is.null(intro.regression())) return(NULL)
        
        myresid <- resid(intro.regression())
        
        yy <- quantile(myresid, na.rm = TRUE, c(0.25, 0.75))
        xx <- qnorm(c(0.25, 0.75))
        slope <- diff(yy) / diff(xx)
        int <- yy[1] - slope * xx[1]
        
        mydat <- data.frame(yy = qnorm(seq(0, 1, by = (1/(length(na.omit(myresid)) + 1)))[-c(1, (length(na.omit(myresid)) + 2))]),
                            residuals = sort(myresid))
        
        return(mydat)
    })
    
    reg.resid2 %>%
        ggvis(x = ~yy, y = ~residuals) %>%
        layer_points() %>%
        set_options(width = 200, height = 200) %>% 
        bind_shiny("resplot2")
    
    reg.resid1 %>%
        ggvis(x = ~residuals) %>%
        layer_histograms() %>%
        set_options(width = 200, height = 200) %>%
        bind_shiny("resplot3")

    dt.options <- reactive({list(pageLength = 10,
                                 searching=0,
                                 destroy=1,
                                 headerCallback =  I(paste0("function(thead, data, start, end, display) {
                                               //color code the header items
                                               var col_types = [", 
                                                            paste(paste0("'", ifelse(grepl("factor", whatis(intro.data())$type), "categorical", ifelse(grepl("character", whatis(intro.data())$type), "categorical", "numeric")),"'"),
                                                                  collapse=", "),
                                                            "]
                                               var headers = $(thead).find('th');

                                               for(i = 0; i < col_types.length; i++) {
                                                if(col_types[i] == 'categorical') headers[i].style.color = '#95a5a6';
                                                else headers[i].style.color = '#3498db';
                                               }

                                              if($('.dataTables_length').parent().next().find('span').length == 0) $('.dataTables_length').parent().next().append('<div, style=\"float:right\"><span style=\"color:#95a5a6\">Categorical Variable</span><span style=\"color:#3498db\">     Numeric Variable</span></div>')
                                            }")
                                 ))})


    ###
    ### Outputs
    ###
    output$data <- renderDataTable({  
      return(intro.data())
    }, options = dt.options)
    
    output$downloaddata <- downloadHandler(
        filename = function() { paste0("intro_data_", today(), ".csv") },
        content = function(file) {
            write.csv(intro.data(), file)
        }
    )

    output$mosaicplot <- renderPlot({
        return(print(mosaicplot(intro.data(), input$x, input$y, intro.numericnames(), intro.categoricnames())))
    })
    
    output$conttable <- renderTable({
        return(cont.table(intro.data(), input$xcont, input$ycont))
    }, digits = 0)
    
    output$summary <- renderTable({
        return(summarytable(intro.data(), input$tblvars))
    }, include.rownames = FALSE)
    
    q1 <- function(x) { return(quantile(x, .25)) }
    q3 <- function(x) { return(quantile(x, .75)) }
    
    output$new_summary <- renderPrint({
        if (is.null(input$tblvars)){
            return(NULL)    
        } else if (input$grouping == "none") {
            return(summary(intro.data()[,input$tblvars]))
        } else {
            dat <- intro.data()[,input$tblvars]
            dat$intro_grouping <- intro.data()[,input$grouping]
            
            dat.dplyr <- dat[,names(dat) %in% c("intro_grouping", numericNames(dat))] %>% group_by(intro_grouping) %>% summarise_each(funs(min, q1, median, q3, max, mean, sd))
            dat.dplyr.df <- as.data.frame(dat.dplyr)
            names(dat.dplyr.df)[1] <- input$grouping
            
            return(dat.dplyr.df)
        }
    })
    
    output$regtable <- renderTable({
        if (!(input$xreg %in% intro.numericnames()) | !(input$yreg %in% intro.numericnames())) return(NULL)
        
        return(tablereg(intro.data(), input$xreg, input$yreg, intro.regression()))
    })
    
    output$r <- renderText({
        if (!(input$xreg %in% intro.numericnames()) | !(input$yreg %in% intro.numericnames())) return(NULL)
        
        return(r(intro.data(), input$xreg, input$yreg, intro.regression()))
    })
    
    output$r2 <- renderText({
        if (!(input$xreg %in% intro.numericnames()) | !(input$yreg %in% intro.numericnames())) return(NULL)
        
        return(r2(intro.data(), input$xreg, input$yreg, intro.regression()))
    })
    
    output$ttesttable <- renderText({
        if (!(input$group1 %in% intro.numericnames())) return(NULL)
        
        return(ttesttable(intro.data(), input$group1, input$group2, input$varts == "twovart", input$conflevel, input$althyp, input$hypval))
    })
})
