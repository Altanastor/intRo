library(shiny)
library(ggplot2)
library(ggvis)
library(shinyAce)
library(YaleToolkit)
library(lubridate)
library(gridExtra)

numericNames <- function(data) {
    return(as.character(subset(whatis(data), type == "numeric" & !(variable.name %in% c("year", "month", "day", "Year", "Month", "Day")))$variable.name))
}

shinyServer(function(input, output, session) {
    
    textStorage <- paste("### Code generated by intRo on", today(), "\n\n")
    values <- reactiveValues(firstrun = TRUE)
    
    sourceDir <- function(path, ...) { for (nm in list.files(path, pattern = "\\.[Rr]$")) { source(file.path(path, nm), ...) } }
    sourceDir("modules")
    valid.trans <- list(I = I, log = log, sqrt = sqrt)
    valid.datasets <- list(mpg = mpg, airquality = airquality, diamonds = diamonds)
    valid.plottypes <- list(scatterplot = scatterplot, linechart = linechart,
                            histogram = histogram,
                            boxplot = boxplot, barchart = barchart,
                            paretochart = paretochart,
                            quantileplot = quantileplot,
                            mosaicplot = mosaicplot)
    valid.bartypes <- list(length = length, sum = sum, mean = mean, median = median)
    
    checkVariable <- function(data, var) {
        return(nchar(var) > 0 & var %in% names(data))
    }
    
    observe({
        curdata <- intro.data()
        curx <- input$var_trans
        
        if (checkVariable(curdata, curx)) {
            trans_x <- valid.trans[[input$trans]](curdata[,curx])
            curdata[, paste(curx, input$trans, sep = "_")] <- as.numeric(trans_x)
            plot_var_trans(curdata, paste(curx, input$trans, sep = "_")) %>% bind_shiny("trans_plot")
        }
    })
    
    ### Plot Options Observe
    ### Can't be in above because of inter-dependency with plot call
    observe({
        curdata <- intro.data()
        curx <- input$x
        cury <- input$y
        
        if (checkVariable(curdata, curx) & checkVariable(curdata, cury)) {
            updateNumericInput(session, "binwidth", value = (range(curdata[,curx], na.rm = TRUE)[2] - range(curdata[,curx], na.rm = TRUE)[1]) / 30, step = (range(curdata[,curx], na.rm = TRUE)[2] - range(curdata[,curx], na.rm = TRUE)[1]) / 300)
        }
    })
    
    observe({
        curdata <- intro.data()
        curx <- input$x
        cury <- input$y
        binwidth <- input$binwidth
        addy <- input$addy
        
        if (checkVariable(curdata, curx) & (checkVariable(curdata, cury) | !addy)) {
            chosen.plot()(curdata, curx, cury, chosen.bartype(), binwidth, addy) %>% bind_shiny("plot")
        }
    })
    
    observe({
        curdata <- intro.data()
        curxreg <- input$xreg
        curyreg <- input$yreg
                        
        if (curxreg %in% names(curdata) & curyreg %in% names(curdata)) {
            scatterplotreg(curdata, input$xreg, input$yreg) %>% bind_shiny("regplot")
            residualreg1(intro.data(), curxreg, curyreg) %>% bind_shiny("resplot1")
            residualreg2(intro.data(), curxreg, curyreg) %>% bind_shiny("resplot2")
            residualreg3(intro.data(), curxreg, curyreg) %>% bind_shiny("resplot3")
        }
    })
    
    observe({
        updateSelectInput(session, "var_trans", choices = numericNames(intro.data()), selected = ifelse(checkVariable(intro.data(), input$var_trans), input$var_trans, numericNames(intro.data())[1]))
        updateSelectInput(session, "x", choices = numericNames(intro.data()), selected = ifelse(checkVariable(intro.data(), input$x), input$x, numericNames(intro.data())[1]))
        updateSelectInput(session, "y", choices = numericNames(intro.data()), selected = ifelse(checkVariable(intro.data(), input$y), input$y, numericNames(intro.data())[2]))
        updateSelectInput(session, "xreg", choices = numericNames(intro.data()), selected = ifelse(checkVariable(intro.data(), input$xreg), input$xreg, numericNames(intro.data())[1]))
        updateSelectInput(session, "yreg", choices = numericNames(intro.data()), selected = ifelse(checkVariable(intro.data(), input$yreg), input$yreg, numericNames(intro.data())[2]))
        updateSelectInput(session, "group1", choices = numericNames(intro.data()), selected = ifelse(checkVariable(intro.data(), input$group1), input$group1, numericNames(intro.data())[1]))
        updateSelectInput(session, "group2", choices = numericNames(intro.data()), selected = ifelse(checkVariable(intro.data(), input$group2), input$group2, numericNames(intro.data())[2]))
        updateCheckboxGroupInput(session, "tblvars", choices = names(intro.data()))
    })
    
    process_logical <- function(data, x) {
        if (is.null(x)) {
            return(data)
        }

        relevant_cols <- names(data)[nchar(x) > 0]
        my_strs <- strsplit(gsub(",", " , ", x), split = ",")
        new_strs <- my_strs[unlist(lapply(my_strs, length)) > 0]

        new_data <- data
        if (length(new_strs) > 0) {
            for (i in 1:length(new_strs)) {
                test <- new_strs[[i]]
                col <- relevant_cols[i]
                
                subset_str <- ""
                if (length(test) == 1) {
                    if (is.na(as.numeric(test[1]))) {
                        subset_str <- paste0("'", test[1], "' == ", col)
                    } else {
                        subset_str <- paste(test[1], "==", col)
                    }
                } else {
                    test[1] <- ifelse(test[1] == " ", -Inf, test[1])
                    test[2] <- ifelse(test[2] == " ", Inf, test[2])
                    if (is.na(test[2])) test[2] <- Inf
                    
                    subset_str <- paste(test[1], "<=", col, "&", col, "<=", test[2])
                }          
                new_data <- eval(parse(text = paste0("subset(new_data, ", subset_str, ")")))
            }
        }
                
        return(new_data)
    }
    
    mydat <- NULL
    oldval <- 0
    intro.start <- reactive({
        
        #dependency on input$clearssubset
        if (input$clearsubset > oldval) {
            updateCheckboxInput(session, "randomsub", value = FALSE)
            oldval <<- input$clearsubset
        }
      
        data.initial <- data.module(input$data_own, chosen.data(), input$own)
        
        if (values$firstrun) textStorage <<- paste(textStorage, "### ", input$`side-nav`,"\n", paste(c(readLines(paste("modules/", input$`side-nav`, ".R", sep = ""))), collapse = "\n"), "\n\n", sep = "")
        
        if (values$firstrun) {
            updateAceEditor(session, "myEditor", value=textStorage)
            values$firstrun <- FALSE
        }
                
        mydat <<- data.initial
                
        return(data.initial)
    })
    
    oldsaveresid <- 0
    oldsavetrans <- 0
    mydatbak <- NULL
    
    intro.data <- reactive({
        if (is.null(intro.start())) return(NULL)

        data.subset <- process_logical(mydat, input$subs)
        mydat <<- data.subset
        if (input$randomsub) { 
            mydatbak <<- mydat            
            mydat <<- dplyr::sample_n(intro.start(), input$randomsubrows)
        } else if (!input$randomsub & !is.null(mydatbak)) {
            mydat <<- mydatbak
            mydatbak <<- NULL
        }
        
        if (input$saveresid > oldsaveresid) {
            curxreg <- input$xreg
            curyreg <- input$yreg
            
            if (curxreg %in% names(mydat) & curyreg %in% names(mydat)) {
                mydat <<- savefit(mydat, input$xreg, input$yreg)
            }
            
            oldsaveresid <<- input$saveresid
        }
        
        if (input$savetrans > oldsavetrans) {
            curtrans <- input$var_trans
            
            if (curtrans %in% names(mydat)) {
                trans_x <- valid.trans[[input$trans]](mydat[,curtrans])
                mydat[,paste(curtrans, input$trans, sep = "_")] <<- as.numeric(trans_x)
                
                updateRadioButtons(session, "trans", selected = "I")
            }
            
            oldsavetrans <<- input$savetrans
        }
        
        return(mydat)
    })

    observe({
        if (!values$firstrun) {
            new.tab <- input$`side-nav`
            new.str <-  paste("### ", paste(input$`side-nav`, "\n", paste(readLines(paste("modules/", new.tab, ".R", sep = "")), collapse = "\n"), sep = ""), "\n\n", sep = "")
            
            ### Special case for plots
            if (input$`side-nav` == "Graphical") {
                new.str <- paste("### ", paste(new.tab, "\n", input$plottype, " <- ", paste(deparse(get(input$plottype)), collapse = "\n"), sep = ""), "\n\n", sep = "")
            }
            
            text.split <- strsplit(textStorage, "### ")[[1]]
            text.split <- text.split[-(text.split == "")]
            text.ind <- grep(input$`side-nav`, text.split)
            if (length(text.ind) == 0) text.ind <- length(text.split) + 1
            text.split[-text.ind] <- paste("###", text.split[-text.ind])
            text.split[text.ind] <- new.str
            
            textStorage <<- paste(text.split, collapse = "")
            
            updateAceEditor(session, "myEditor", value=textStorage)
        }
    })
    
    output$downloaddata <- downloadHandler(
        filename = function() { paste0("intro_data_", today(), ".csv") },
        content = function(file) {
            write.csv(intro.data(), file)
        }
    )
    
    chosen.data <- reactive({
        return(valid.datasets[[input$data]])
    })
    
    chosen.plot <- reactive({
        return(valid.plottypes[[input$plottype]])
    })
    
    chosen.bartype <- reactive({
        return(valid.bartypes[[input$bartype]])
    })

    output$data <- renderDataTable({
        return(intro.data())
    }, options = list(pageLength = 10))
    
    output$trans_out <- renderText({
        return(valid.trans[[input$trans]](intro.data()[,input$var_trans])[1:min(10, nrow(intro.data()))])
    })
    
    output$summary <- renderTable({
        return(summarytable(intro.data(), input$tblvars))
    }, include.rownames = FALSE)
    
    output$regtable <- renderTable({
        if (!(input$xreg %in% numericNames(intro.data())) | !(input$yreg %in% numericNames(intro.data()))) return(NULL)
        else return(tablereg(intro.data(), input$xreg, input$yreg))
    }, digits = 4)
    
    output$r <- renderText({
        if (!(input$xreg %in% numericNames(intro.data())) | !(input$yreg %in% numericNames(intro.data()))) return(NULL)
        else return(r(intro.data(), input$xreg, input$yreg))
    })
    
    output$r2 <- renderText({
        if (!(input$xreg %in% numericNames(intro.data())) | !(input$yreg %in% numericNames(intro.data()))) return(NULL)
        return(r2(intro.data(), input$xreg, input$yreg))
    })
    
    output$ttesttable <- renderText({
        if (!(input$group1 %in% numericNames(intro.data()))) return(NULL)
        return(ttesttable(intro.data(), input$group1, input$group2, input$varts == "twovart", input$conflevel, input$althyp, input$hypval))
    })
})
